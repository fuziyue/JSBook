替换,可理解为剪切 : 会把所有内容和事件都剪切过去;
        replaceChild 
        父级.replaceChild(替换的元素,被替换的元素)


cloneNode(true/false)克隆(复制)元素 :  
        true : 把元素里面的所有内容都克隆过去;
        false : 只克隆元素,不克隆元素里面的所有内容;
        默认(不传参)为false;
        	
注意 : 克隆只能克隆元素内容,不能克隆元素事件,包括元素内容的事件也不行;


DOM:元素;
DOM元素事件:
        onclick
        onmouseover //在元素内部从父级元素到子级元素也会被触发;
        onmouseout  //在元素内部从父级元素到子级元素也会被触发;
        onchange
        		
        ondblclick:双击事件;
        onmouseenter:鼠标移入事件;
        onmouseleave:鼠标移出事件;
        		
        onmousemove:鼠标移动事件;
        onmousedown:鼠标按下事件;
        onmouseup:鼠标抬起事件;

	onkeydown:键盘按下事件;
        onkeyup:键盘抬起事件;

	oninput:只要value值发生改变就会触发事件;
        	
        onchange:value值发生改变,还要失去光标才会触发事件;
        	
        onblur:输入框失去光标触发事件;
        	
        onfocus:输入框获取光标触发事件;	
        		
BOM:window; Browser(浏览器) Object(对象)  Modle(模型);
        window.onload ： 加载DOM结构(也叫加载元素)完毕,触发事件;
	window.onscoll : 滚动条滚动事件;
        window.onresize : 可视区宽度发生改变触发事件;


BOM : 学习浏览器已经开放的、方法、事件、属性；
BOM没有标准，每个浏览器厂商都有自己的一套方法，但大多数都差不多，因为要同一兼容；
			
				在BOM里学的就是window，window ： 浏览器最大的一个对象；

open(参数一，参数二，参数三，参数四) : 打开一个新窗口；
			参数一 ： 在创建的新窗口里面，打开一个页面，参数是页面的路劲；
			参数二 ： 是否在当前窗口打开新页面，默认会打开一个新窗口；
					_blank : 打开一个新窗口；
					_self : 当前窗口；
			参数三 ： 要用参数三，参数二必须要设置_blank（打开一个新窗口）才有效果，设置新窗口的大小，不写就默认为全屏；
			参数四 ：没有作用；

cloce() : 关闭浏览器窗口；
        	有三种情况：
        		一、在谷歌浏览器里面，直接关闭窗口；
        		二、在IE浏览器里面，会再次确定是否关闭；
        		三、在火狐浏览器里面，没有效果；
        		
        	兼容：页面用open()方法打开，然后都可以使用cloce()方法；


window.location : 地址栏对象；
        		对象里面包含了地址栏的信息	
			href : 字符串形式的路径；
        		search : 地址栏里面 ?问号后面的值；
        			作用：当重新给search赋值的时候，浏览器会在窗口自动的刷新一遍；
			hash : 地址栏#号后面的数；除非人为改变hash值，否则如何刷新都不会变；
        			当设置hash时，浏览器自己会添加#；
        	
        	事件：
        	window.onhashchange : hash值发生改变，触发函数；

用户代理信息 : 获取打开页面用的浏览器是在的什么系统，什么型号，什么浏览器；
        	window.navigator.userAgent；

window.innerWidth:可获取可视区的宽度；
        	window.innerHeight:可获取可视区的高度；

这个只能获取Y轴的滚动条的位置，不能设置：
        		window.pageYOffset
        	这个只能获取X轴的滚动条的位置，不能设置：
        		window.pageXOffset	
        	设置XY轴的滚动条的位置：	
        		window.scollTo(x,y)


传统事件：就是以on开头的事件；
        		特点：只能有一个值，如果同一个函数有多个值的话，会被覆盖；
        		
        	绑定事件：
        	box.addEventListener(参数一，参数二，参数三) : 事件绑定函数；
        		参数一：不带on的事件名；如：click;
        		参数二：要执行的函数，函数里面写执行代码；如：function(){};
        		参数三：true(捕获)/默认为false(冒泡)；
        			捕获：从外面往里面触发事件；
        			冒泡：从里面往外面触发事件；
        		特点：同一个元素可以拥有多个相同的事件，而且多个事件是不会覆盖和相互影响；
        	
        	IE(低版本)专属绑定事件：
        		attachEvent(参数一，参数二);
        			参数一：带on的事件名；
        			参数二：执行的函数；
        		注明：在执行函数里面写this在	IE(低版本)专属绑定事件里面只能指的是window这个浏览器最大的对象；

this的指向：函数被调用时，函数名前面的对象是谁，执行函数时this就是谁；
        		1、函数是被事件触发执行的，在这次执行的代码里面，这个this指的就是这个事件的元素；
        		2、直接的普通函数调用，this指的是window这个对象；
        		3、在定时器里面的this指的是window这个对象；
        		4、obj（对象）里面的属性是一个函数，调用这个属性函数，这里面的this就是这个对象；      		


改变this的指向方法：
        		call(参数一，参数二) : 在函数调用的时候，可以改变函数执行时里面this的指向；
        		参数一：this所代表的对象；
        		参数二：函数里面对应的实参；
        		例如：
        			function fn(a,b,c){};
        			fn.call(box,1,2,3);
        			
        		apply(参数一，参数二) : 也是在函数调用的时候，可以改变函数执行时里面this的指向；
        			参数一：this所代表的对象；
        			参数二：函数里面实参是数组对应形参；
        		例如：
        			function fn(a,b,c){};
        			fn.apply(box,[1,2,3]);
        		
        	注明：call和apply方法是一样的，唯一区别就是apply参数二实参里放的是数组和形参一一对应；

解除函数的方法 ： 
        		1、对于传统事件：重新给这个事件赋值为null；
        		2、对于绑定事件：removeEventListener();
        			box.removeEventListener(参数一，参数二)；
        			参数一：不带on的解除的那个事件名；
        			参数二：解除那个事件的函数的函数名；
        			例如：
        				box.addEventListener('click',function fn(){});
        				box.removeEventListener('click',fn);

			3、IE低版本解除绑定事件：box.datechEvent('onclick',function fn(){});
        			参数一：带on的事件；
        			参数二：解绑的函数名；

事件机制（又叫事件流）：捕获过程+冒泡过程；
        		要有两个条件才会触发：
        		1、必须是事件元素的祖先元素；
        		2、事件元素与祖先元素拥有相同的事件名；
        		
        		走向：
        			一、捕获：当一个元素的事件被触发，浏览器会沿着window一层一层往下走，一直找到目标元素为止，这个阶段我们称为捕获过程；
        			二、冒泡：当目标元素的事件执行完，在沿着祖先元素一层一层往上走，一直到window为止，这个阶段我们称为冒泡过程；
        		
        		在事件机制的过程中，会发生一个事情，会把祖先元素的事件也给触发；
        		在传统事件里面，所有的祖先元素的事件都是在冒泡过程被触发；
        		
        		捕获过程触发函数：
        			addEventListener(参数三)，只有参数三才有改变事件机制的方法，而IE低版本就不能，只能和传统事件一样都是从冒泡过程被触发；

事件对象：当事件来触发函数时，浏览器会自动的往函数里面传一个实参，而这个实参是一个对象，而我们把这个对象就叫做事件对象；
        		事件对象里面包含了浏览器的一些信息；
        		
        		在IE浏览器里面window里面有一个属性，属性名叫做event，和事件对象一样；
        		
        		.cancelBubble : 阻止冒泡机制,兼容所有浏览器，但是它并不是W3C标准；
        			false : 有冒泡机制；
        			true : 没有冒泡机制；
        			
        		.stopPropagation() : 阻止冒泡的，是W3C的标准，但是IE低版本浏览器不兼容；


event 事件对象里面有一个target,把这个叫做事件源：是一个元素，是事件触发开始的元素；
        	事件源也被称为事件监听；
        	好处 ： 减少代码，代码的性能更高；


键盘事件的event事件对象：
        		在键盘事件里面的时候，这个event事件对象有一个keyCode属性,它是键盘的一个键值；
        		
        		键盘里的特殊键：当按的是特殊键时，相应的键会变成true;
        			event.altKey
        			event.ctrlKey
        			event.shiftKey

pageX : 鼠标光标离目标元素最左边的距离；
        	pageY : 鼠标光标离目标元素最上边的距离；




浏览器默认行为：
        		浏览器会赋予页面一些功能。
        		如：点击a标签跳转，点击右键会弹出菜单等等。
        		
        		preventDefault() : 阻止浏览器的所有默认行为,不用传参；
        	
        	oncontextmenu : 鼠标右击事件；